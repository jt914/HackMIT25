import json
import numpy as np
from manim import *
from gtts import gTTS
import os
import requests
import base64

def upload_to_imgur(video_path, client_id="546c25a59c58ad7"):
    """
    Upload video to Imgur and return the shareable link.
    Uses a public client ID - for production, get your own from https://api.imgur.com/oauth2/addclient
    
    IMGUR LIMITS:
    - Max file size: 200MB
    - Max duration: 60 seconds
    - Upload rate: 50 uploads/hour
    """
    url = "https://api.imgur.com/3/upload"
    headers = {"Authorization": f"Client-ID {client_id}"}
    
    try:
        with open(video_path, 'rb') as f:
            # Imgur accepts both files and base64
            files = {'video': f}
            data = {
                'type': 'file',
                'title': f'Generated Video - {os.path.basename(video_path)}',
                'description': 'Video generated by Manim'
            }
            
            print(f"Uploading {video_path} to Imgur...")
            response = requests.post(url, headers=headers, files=files, data=data)
            
            if response.status_code == 200:
                result = response.json()
                if result['success']:
                    link = result['data']['link']
                    print(f"‚úÖ Upload successful! Link: {link}")
                    return link
                else:
                    print(f"‚ùå Upload failed: {result}")
                    return None
            else:
                print(f"‚ùå HTTP Error {response.status_code}: {response.text}")
                return None
                
    except Exception as e:
        print(f"‚ùå Error uploading to Imgur: {str(e)}")
        return None

class TextBulletVideo(Scene):
    def construct(self):
        # This will be dynamically set by the JSON data
        pass

def create_text_bullet_video_from_json(json_file_path, output_filename="text_bullet_video.mp4", upload_to_imgur_flag=True):
    """
    Creates a video with narration and animated bullet points from a JSON script file
    """
    # Load the JSON script
    with open(json_file_path, 'r') as f:
        script_data = json.load(f)
    
    # Generate audio narration
    audio_filename = None
    if "audio" in script_data and "narration" in script_data["audio"]:
        tts = gTTS(
            text=script_data["audio"]["narration"], 
            lang=script_data["audio"].get("language", "en")
        )
        audio_filename = "temp_narration.mp3"
        tts.save(audio_filename)
    
    # Create a temporary Python file for manim
    temp_scene_file = "temp_text_scene.py"
    
    scene_code = f'''
import json
import numpy as np
from manim import *

class TextBulletScene(Scene):
    def construct(self):
        script_data = {json.dumps(script_data, indent=2)}
        
        # Create title
        title = Text(script_data["title"], font_size=48, color=WHITE)
        title.to_edge(UP, buff=1)
        self.play(Write(title))
        self.wait(1)
        
        # Get bullet points and timing
        bullets = script_data["bullets"]
        timing = script_data.get("timing", {{}})
        
        # Create bullet points
        bullet_objects = []
        for i, bullet in enumerate(bullets):
            bullet_text = Text(f"‚Ä¢ {{bullet['text']}}", font_size=36, color=WHITE)
            bullet_text.move_to(UP * (2 - i * 1.2))  # Space them vertically
            bullet_objects.append(bullet_text)
        
        # Animate bullet points appearing one by one
        for i, bullet_obj in enumerate(bullet_objects):
            # Highlight effect - make it yellow briefly, then white
            bullet_obj.set_color(YELLOW)
            self.play(
                Write(bullet_obj), 
                run_time=timing.get("bullet_appear_duration", 1.0)
            )
            self.wait(timing.get("bullet_highlight_duration", 2.0))
            
            # Change to normal color
            self.play(
                bullet_obj.animate.set_color(WHITE),
                run_time=0.3
            )
            self.wait(timing.get("pause_between_bullets", 0.5))
        
        # Keep all bullets visible for final pause
        self.wait(timing.get("final_pause", 2.0))
'''
    
    # Write the temporary scene file
    with open(temp_scene_file, 'w') as f:
        f.write(scene_code)
    
    try:
        # Render the video using manim
        os.system(f"manim -qm {temp_scene_file} TextBulletScene")
        
        # The rendered video will be in media/videos/temp_text_scene/720p30/TextBulletScene.mp4
        rendered_path = "media/videos/temp_text_scene/720p30/TextBulletScene.mp4"
        
        if os.path.exists(rendered_path):
            # If we have audio, combine it with the video
            if audio_filename and os.path.exists(audio_filename):
                from moviepy import VideoFileClip, AudioFileClip, CompositeAudioClip
                
                video_clip = VideoFileClip(rendered_path)
                audio_clip = AudioFileClip(audio_filename)
                
                # Extend the shorter one to match the longer duration
                if video_clip.duration < audio_clip.duration:
                    # Extend video by freezing the last frame
                    from moviepy import ImageClip
                    last_frame = video_clip.get_frame(video_clip.duration)
                    freeze_frame = ImageClip(last_frame, duration=audio_clip.duration - video_clip.duration)
                    from moviepy import concatenate_videoclips
                    video_clip = concatenate_videoclips([video_clip, freeze_frame])
                elif audio_clip.duration < video_clip.duration:
                    # Extend audio by adding silence
                    from moviepy import AudioArrayClip
                    import numpy as np
                    silence_duration = video_clip.duration - audio_clip.duration
                    silence = AudioArrayClip(np.zeros((int(silence_duration * audio_clip.fps), audio_clip.nchannels)), 
                                           fps=audio_clip.fps)
                    from moviepy import concatenate_audioclips
                    audio_clip = concatenate_audioclips([audio_clip, silence])
                # If durations are equal, no adjustment needed
                
                final_video = video_clip.with_audio(audio_clip)
                final_video.write_videofile(output_filename, codec='libx264', audio_codec='aac')
                
                # Clean up
                video_clip.close()
                audio_clip.close()
                final_video.close()
            else:
                # Just copy the rendered video
                import shutil
                shutil.copy(rendered_path, output_filename)
            
            print(f"Video created successfully: {output_filename}")
            
            # Upload to Imgur if requested
            if upload_to_imgur_flag:
                imgur_link = upload_to_imgur(output_filename)
                if imgur_link:
                    print(f"üîó Shareable link: {imgur_link}")
                    return {"local_path": output_filename, "imgur_link": imgur_link}
                else:
                    print("Upload failed, but video is available locally")
                    return {"local_path": output_filename, "imgur_link": None}
            else:
                return {"local_path": output_filename, "imgur_link": None}
        else:
            print("Error: Rendered video not found")
            return None
    
    finally:
        # Clean up temporary files
        if os.path.exists(temp_scene_file):
            os.remove(temp_scene_file)
        if audio_filename and os.path.exists(audio_filename):
            os.remove(audio_filename)


# Example usage
if __name__ == "__main__":
    result = create_text_bullet_video_from_json("example_text_script.json", "text_bullet_video.mp4")
    if result and result["imgur_link"]:
        print(f"\nüé¨ Your video is ready!")
        print(f"üìÅ Local file: {result['local_path']}")
        print(f"üåê Share this link: {result['imgur_link']}")
    elif result:
        print(f"\nüé¨ Video created locally: {result['local_path']}")
    else:
        print("‚ùå Video creation failed")
